import { __values, __spread } from 'tslib';
import { InjectionToken, Injectable, Inject, Component, ChangeDetectionStrategy, ChangeDetectorRef, EventEmitter, Input, Output, ContentChildren, ElementRef, Renderer2, ViewChild, Directive, forwardRef, NgModule } from '@angular/core';
import { BehaviorSubject, fromEvent } from 'rxjs';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { map, debounceTime, withLatestFrom } from 'rxjs/operators';
import { FormBuilder, FormControl, Validators, NG_VALUE_ACCESSOR, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { OverlayModule } from '@angular/cdk/overlay';
import { PortalModule } from '@angular/cdk/portal';
import { MatButtonModule, MatFormFieldModule, MatInputModule } from '@angular/material';
import { ScrollDispatchModule } from '@angular/cdk/scrolling';

var EMPTY_COLOR = new InjectionToken('empty-color');
function coerceHexaColor(color) {
    if (color && color.indexOf('#') !== 0) {
        color = "#" + color;
    }
    if (!isValidColor(color)) {
        return;
    }
    return color.toUpperCase();
}
function isValidColor(color) {
    if (!color || color.charAt(0) !== '#' || color.length > 7) {
        return false;
    }
    var hex = color.replace('#', '');
    if (hex.length === 6) {
        var r = parseInt(hex.slice(0, 2), 16);
        var g = parseInt(hex.slice(2, 4), 16);
        var b = parseInt(hex.slice(4, 6), 16);
        if (Number.isNaN(r) || Number.isNaN(g) || Number.isNaN(b)) {
            return false;
        }
    }
    return true;
}
var MccColorPickerService = /** @class */ (function () {
    function MccColorPickerService(emptyColor) {
        this.emptyColor = emptyColor;
        this._colors = new BehaviorSubject([]);
    }
    MccColorPickerService.prototype.addColor = function (color) {
        if (!color || !isValidColor(color)) {
            return;
        }
        color = coerceHexaColor(color) || this.emptyColor;
        var colors = this._colors.getValue();
        if (!colors.find(function (_color) { return _color === color; })) {
            colors.push(color);
            this._colors.next(colors);
        }
    };
    MccColorPickerService.prototype.getColors = function () {
        return this._colors.asObservable();
    };
    MccColorPickerService.prototype.resetUseColors = function () {
        this._colors.next([]);
    };
    return MccColorPickerService;
}());
MccColorPickerService.decorators = [
    { type: Injectable },
];
MccColorPickerService.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: Inject, args: [EMPTY_COLOR,] },] },
]; };
var MccColorPickerCollectionComponent = /** @class */ (function () {
    function MccColorPickerCollectionComponent(changeDetectorRef, emptyColor) {
        this.changeDetectorRef = changeDetectorRef;
        this.emptyColor = emptyColor;
        this._hideEmpty = false;
        this.size = 30;
        this.transparent = false;
        this.changeColor = new EventEmitter();
    }
    Object.defineProperty(MccColorPickerCollectionComponent.prototype, "hideEmpty", {
        set: function (value) {
            this._hideEmpty = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerCollectionComponent.prototype, "label", {
        get: function () {
            return this._label;
        },
        set: function (value) {
            this._label = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerCollectionComponent.prototype, "colors", {
        get: function () {
            return this._colors;
        },
        set: function (values) {
            this._colors = values;
        },
        enumerable: true,
        configurable: true
    });
    MccColorPickerCollectionComponent.prototype.ngAfterContentChecked = function () {
        if (this._colors && this._colors.length !== this.size) {
            this._colors = this._colors
                .slice(0, this.size)
                .concat(new Array(this._getCollectionDiffSize()));
            this.changeDetectorRef.markForCheck();
        }
    };
    MccColorPickerCollectionComponent.prototype._getCollectionDiffSize = function () {
        if (this._colors.length > this.size || this._hideEmpty) {
            return 0;
        }
        return this.size - this._colors.length;
    };
    MccColorPickerCollectionComponent.prototype.setTransparent = function () {
        this.changeColor.emit(this.emptyColor);
    };
    MccColorPickerCollectionComponent.prototype.setColor = function (option) {
        var color = typeof option === 'string' ? option : option.value;
        this.changeColor.emit(color);
    };
    return MccColorPickerCollectionComponent;
}());
MccColorPickerCollectionComponent.decorators = [
    { type: Component, args: [{
                selector: 'mcc-color-picker-collection',
                template: "<div class=\"mcc-color-picker-collection\" role=\"listbox\" aria-label=\"Select a color\">\n        <h3>{{ label }}</h3>\n        <button mat-mini-fab *ngIf=\"transparent\" class=\"mcc-color-picker-remove-color mat-elevation-z0\" role=\"option\" aria-label=\"transparent\"\n                (click)=\"setTransparent()\">\n                <div class=\"mcc-color-picker-transparent\"></div>\n        </button>\n        <button *ngFor=\"let color of colors\" mat-mini-fab class=\"mat-elevation-z0\" role=\"option\" [disabled]=\"!color || color === emptyColor\"\n                [mccColorPickerOption]=\"color\" (click)=\"setColor(color)\">\n        </button>\n</div>",
                styles: [".mcc-color-picker-collection{min-height:50px;padding:10px 18px}.mcc-color-picker-collection h3{color:#100214;text-transform:uppercase;font-family:'Open Sans',sans-serif;font-size:12px;font-weight:700;margin:0 0 10px}.mcc-color-picker-remove-color{background-color:#fff;border:1px solid #e1e1e1}.mcc-color-picker-remove-color .mcc-color-picker-transparent{width:20px;height:1px;border-bottom:1px solid red;transform:translateY(-4px) translateX(0) rotate(45deg);-webkit-transform:translateY(-4px) translateX(0) rotate(45deg)}button{width:22px;height:22px;cursor:pointer;margin:3px}"],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
MccColorPickerCollectionComponent.ctorParameters = function () { return [
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Inject, args: [EMPTY_COLOR,] },] },
]; };
MccColorPickerCollectionComponent.propDecorators = {
    "hideEmpty": [{ type: Input },],
    "label": [{ type: Input },],
    "colors": [{ type: Input },],
    "size": [{ type: Input },],
    "transparent": [{ type: Input },],
    "changeColor": [{ type: Output },],
};
var MccColorPickerComponent = /** @class */ (function () {
    function MccColorPickerComponent(elementRef, changeDetectorRef, colorPickerService, emptyColor) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.colorPickerService = colorPickerService;
        this.emptyColor = emptyColor;
        this._usedColorLabel = 'Used Colors';
        this._reverseUsedColor = false;
        this._hideHexForms = false;
        this._hideEmpty = false;
        this._hideTransparent = false;
        this._hideUsedColors = false;
        this._isOpen = false;
        this._overlay = true;
        this._hideButtons = false;
        this._colorPickerSelectorHeight = 170;
        this._hideColorPickerSelector = false;
        this.usedSizeColors = 30;
        this.btnCancel = 'Cancel';
        this.btnConfirm = 'Confirm';
        this.change = new EventEmitter();
        this.selected = new EventEmitter();
        this.clickOut = new EventEmitter();
        this._collectionSubs = [];
    }
    Object.defineProperty(MccColorPickerComponent.prototype, "usedColorLabel", {
        get: function () {
            return this._usedColorLabel;
        },
        set: function (value) {
            this._usedColorLabel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "usedColorStart", {
        set: function (colors) {
            if (colors && colors.length > 0) {
                try {
                    for (var colors_1 = __values(colors), colors_1_1 = colors_1.next(); !colors_1_1.done; colors_1_1 = colors_1.next()) {
                        var color = colors_1_1.value;
                        this.colorPickerService.addColor(color);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (colors_1_1 && !colors_1_1.done && (_a = colors_1.return)) _a.call(colors_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            var e_1, _a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "reverseUsedColors", {
        set: function (reverse) {
            this._reverseUsedColor = coerceBooleanProperty(reverse);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideHexForms", {
        get: function () {
            return this._hideHexForms;
        },
        set: function (value) {
            this._hideHexForms = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideEmpty", {
        get: function () {
            return this._hideEmpty;
        },
        set: function (value) {
            this._hideEmpty = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideTransparent", {
        get: function () {
            return this._hideTransparent;
        },
        set: function (value) {
            this._hideTransparent = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideUsedColors", {
        get: function () {
            return this._hideUsedColors;
        },
        set: function (value) {
            this._hideUsedColors = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "selectedColor", {
        get: function () {
            return this._selectedColor;
        },
        set: function (value) {
            if (this._selectedColor !== value) {
                this.changeDetectorRef.markForCheck();
            }
            this._selectedColor = coerceHexaColor(value) || this.emptyColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "isOpen", {
        get: function () {
            return this._isOpen;
        },
        set: function (value) {
            this._isOpen = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "overlay", {
        get: function () {
            return this._overlay;
        },
        set: function (value) {
            this._overlay = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideButtons", {
        get: function () {
            return this._hideButtons;
        },
        set: function (value) {
            this._hideButtons = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "colorPickerSelectorHeight", {
        get: function () {
            return this._colorPickerSelectorHeight;
        },
        set: function (height) {
            this._colorPickerSelectorHeight = height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideColorPickerSelector", {
        get: function () {
            return this._hideColorPickerSelector;
        },
        set: function (value) {
            this._hideColorPickerSelector = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "tmpSelectedColor$", {
        get: function () {
            return this._tmpSelectedColor.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "usedColors$", {
        get: function () {
            var _this = this;
            return this.colorPickerService
                .getColors()
                .pipe(map(function (colors) { return (!_this._reverseUsedColor ? colors : __spread(colors).reverse()); }));
        },
        enumerable: true,
        configurable: true
    });
    MccColorPickerComponent.prototype.ngOnInit = function () {
        if (!this._selectedColor) {
            this._selectedColor = this.emptyColor;
        }
        this._tmpSelectedColor = new BehaviorSubject(this._selectedColor);
    };
    MccColorPickerComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (this._collections) {
            this._collections.forEach(function (collection) {
                var subscription = collection.changeColor.subscribe(function (color) {
                    _this.updateTmpSelectedColor(color);
                });
                _this._collectionSubs.push(subscription);
            });
        }
    };
    MccColorPickerComponent.prototype.ngOnDestroy = function () {
        if (this._collectionSubs) {
            this._collectionSubs.forEach(function (subscription) {
                if (subscription && !subscription.closed) {
                    subscription.unsubscribe();
                }
            });
        }
    };
    MccColorPickerComponent.prototype._updateSelectedColor = function () {
        if (this._isOpen || !this.overlay) {
            var tmpSelectedColor = this._tmpSelectedColor.getValue();
            if (this._selectedColor !== tmpSelectedColor) {
                this._selectedColor = tmpSelectedColor;
                this.selected.next(this._selectedColor);
            }
            else {
                this.selected.emit(this._selectedColor);
            }
        }
    };
    MccColorPickerComponent.prototype.toggle = function () {
        this._isOpen = !this._isOpen;
        if (!this._isOpen && this._selectedColor !== this.emptyColor) {
            this.colorPickerService.addColor(this._selectedColor);
        }
    };
    MccColorPickerComponent.prototype.backdropClick = function () {
        if (this._hideButtons) {
            this.confirmSelectedColor();
        }
        else {
            this.cancelSelection();
        }
        this.clickOut.emit(null);
    };
    MccColorPickerComponent.prototype.updateTmpSelectedColor = function (color) {
        if (color) {
            this._tmpSelectedColor.next(color);
            this.change.next(color);
            if (this._hideButtons) {
                this._updateSelectedColor();
            }
        }
    };
    MccColorPickerComponent.prototype.cancelSelection = function () {
        this.selected.emit(this._selectedColor);
        this.change.next(this._selectedColor);
        this.toggle();
    };
    MccColorPickerComponent.prototype.confirmSelectedColor = function () {
        this._updateSelectedColor();
        this.toggle();
    };
    return MccColorPickerComponent;
}());
MccColorPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'mcc-color-picker',
                template: "<!-- color picker overlay -->\n<ng-container *ngIf=\"overlay\">\n    <button type=\"button\" class=\"btn-picker\" cdkOverlayOrigin #trigger=\"cdkOverlayOrigin\" [ngClass]=\"{ 'empty': selectedColor === emptyColor }\"\n        [style.background]=\"selectedColor\" (click)=\"toggle()\">\n        <div class=\"transparent\" *ngIf=\"selectedColor === emptyColor\"></div>\n    </button>\n    <ng-template cdkConnectedOverlay cdkConnectedOverlayHasBackdrop cdkConnectedOverlayBackdropClass=\"mcc-color-picker-backdrop\"\n        [cdkConnectedOverlayOrigin]=\"trigger\" [cdkConnectedOverlayOpen]=\"isOpen\" (backdropClick)=\"backdropClick()\">\n        <ng-template [cdkPortalOutlet]=\"overlayPanel\"></ng-template>\n    </ng-template>\n</ng-container>\n<!-- color picker flat -->\n<ng-template *ngIf=\"!overlay\" [cdkPortalOutlet]=\"overlayPanel\"></ng-template>\n<!-- color picker component content -->\n<ng-template cdkPortal #overlayPanel=\"cdkPortal\">\n    <div class=\"mcc-color-picker-overlay mat-elevation-z6\" role=\"dialog\" aria-label=\"Color picker\">\n        <mcc-color-picker-selector *ngIf=\"!hideColorPickerSelector\" [selectedColor]=\"tmpSelectedColor$ | async\" [hideHexForms]=\"hideHexForms\"\n            [height]=\"colorPickerSelectorHeight\" (changeSelectedColor)=\"updateTmpSelectedColor($event)\">\n        </mcc-color-picker-selector>\n        <mcc-color-picker-collection *ngIf=\"!hideUsedColors\" [label]=\"usedColorLabel\" [size]=\"usedSizeColors\" [transparent]=\"!hideTransparent\"\n            [hideEmpty]=\"hideEmpty\" [colors]=\"usedColors$ | async\" (changeColor)=\"updateTmpSelectedColor($event)\">\n        </mcc-color-picker-collection>\n        <ng-content></ng-content>\n        <div *ngIf=\"!hideButtons\" class=\"mcc-color-picker-actions\">\n            <button mat-button role=\"button\" aria-label=\"Cancel\" (click)=\"cancelSelection()\">\n                {{ btnCancel }}\n            </button>\n            <button mat-button role=\"button\" aria-label=\"Confirm\" (click)=\"confirmSelectedColor()\">\n                {{ btnConfirm }}\n            </button>\n        </div>\n    </div>\n</ng-template>",
                styles: ["@import url(https://fonts.googleapis.com/css?family=Open+Sans:400,700);.btn-picker{width:25px;height:25px;cursor:pointer;background:0 0;border:2px solid #ddd}.btn-picker.empty{background:#fff!important}.mcc-color-picker-overlay{display:-webkit-box;display:-ms-flexbox;display:flex;width:260px;min-height:80px;position:relative;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;padding:0;background:#fff;font-family:'Open Sans',sans-serif}.mcc-color-picker-overlay .mcc-color-picker-preview{width:100%;height:8px}.transparent{width:32px;height:2px;border-bottom:2px solid red;transform:translateY(-3px) translateX(-2px) rotate(45deg);-webkit-transform:translateY(-2px) translateX(-11px) rotate(45deg);position:absolute}.mcc-color-picker-actions{display:-webkit-box;display:-ms-flexbox;display:flex;padding:4px;border-top:1px solid #ddd}.mcc-color-picker-actions button{color:#100214;text-transform:uppercase;font-family:'Open Sans',sans-serif;font-size:12px;font-weight:400;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1}"],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
MccColorPickerComponent.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
    { type: MccColorPickerService, },
    { type: undefined, decorators: [{ type: Inject, args: [EMPTY_COLOR,] },] },
]; };
MccColorPickerComponent.propDecorators = {
    "_collections": [{ type: ContentChildren, args: [MccColorPickerCollectionComponent,] },],
    "usedColorLabel": [{ type: Input },],
    "usedColorStart": [{ type: Input },],
    "reverseUsedColors": [{ type: Input },],
    "hideHexForms": [{ type: Input, args: ['hideHexForms',] },],
    "hideEmpty": [{ type: Input, args: ['hideEmptyUsedColors',] },],
    "hideTransparent": [{ type: Input, args: ['hideTransparentUsedColors',] },],
    "hideUsedColors": [{ type: Input, args: ['hideUsedColors',] },],
    "selectedColor": [{ type: Input },],
    "isOpen": [{ type: Input },],
    "overlay": [{ type: Input },],
    "hideButtons": [{ type: Input },],
    "colorPickerSelectorHeight": [{ type: Input },],
    "hideColorPickerSelector": [{ type: Input },],
    "usedSizeColors": [{ type: Input },],
    "btnCancel": [{ type: Input },],
    "btnConfirm": [{ type: Input },],
    "change": [{ type: Output },],
    "selected": [{ type: Output },],
    "clickOut": [{ type: Output },],
};
var MccColorPickerSelectorComponent = /** @class */ (function () {
    function MccColorPickerSelectorComponent(formBuilder, render, emptyColor) {
        this.formBuilder = formBuilder;
        this.render = render;
        this.emptyColor = emptyColor;
        this._height = 170;
        this._selectedColor = '';
        this._hideHexForms = false;
        this.changeSelectedColor = new EventEmitter();
        this._rgbaColor = 'rgba(255,0,0,1)';
        this.textClass = 'black';
        this._isPressed = false;
        this.rgbKeys = ['R', 'G', 'B'];
    }
    Object.defineProperty(MccColorPickerSelectorComponent.prototype, "blockCursor", {
        set: function (el) {
            this._bc = el;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerSelectorComponent.prototype, "stripCursor", {
        set: function (el) {
            this._sc = el;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerSelectorComponent.prototype, "height", {
        set: function (value) {
            this._height = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerSelectorComponent.prototype, "selectorHeight", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerSelectorComponent.prototype, "stripHeight", {
        get: function () {
            return this._height - 10;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerSelectorComponent.prototype, "selectedColor", {
        get: function () {
            return this._selectedColor;
        },
        set: function (value) {
            this._selectedColor = value || this.emptyColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerSelectorComponent.prototype, "hideHexForms", {
        get: function () {
            return this._hideHexForms;
        },
        set: function (value) {
            this._hideHexForms = value;
        },
        enumerable: true,
        configurable: true
    });
    MccColorPickerSelectorComponent.prototype.ngOnInit = function () {
        var _this = this;
        this._tmpSelectedColor = new BehaviorSubject(this._selectedColor);
        this._tmpSelectedColorSub = this._tmpSelectedColor.subscribe(function (color) {
            if (color !== _this._selectedColor && isValidColor(color)) {
                if (_this.hexForm.get('hexCode').value !== color) {
                    _this.hexForm.setValue({ hexCode: color });
                }
                _this.changeSelectedColor.emit(coerceHexaColor(color) || _this.emptyColor);
            }
        });
        this.hexForm = this.formBuilder.group({
            hexCode: [this.selectedColor, [Validators.minLength(7), Validators.maxLength(7)]],
        });
        var rgbGroup = {};
        var rgbValue = this._getRGB();
        this.rgbKeys.forEach(function (key, index) { return (rgbGroup[key] = new FormControl(rgbValue[index], {
            validators: [
                Validators.min(0),
                Validators.max(256),
                Validators.minLength(1),
                Validators.maxLength(3),
            ],
            updateOn: 'blur',
        })); });
        this.rgbForm = this.formBuilder.group(rgbGroup);
        this._onChanges();
    };
    MccColorPickerSelectorComponent.prototype.ngOnChanges = function (changes) {
        if ('selectedColor' in changes && changes['selectedColor'].currentValue !== this.emptyColor) {
            if (!this._isPressed) {
                this._updateRGB();
                this._updateRGBA();
                if (this._blockContext) {
                    this._fillGradient();
                }
            }
            var rgb = this._getRGB();
            var o = Math.round((rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000);
            this.textClass = o > 125 ? 'black' : 'white';
        }
    };
    MccColorPickerSelectorComponent.prototype.ngOnDestroy = function () {
        if (this._tmpSelectedColorSub && !this._tmpSelectedColorSub.closed) {
            this._tmpSelectedColorSub.unsubscribe();
        }
        if (this._hexValuesSub && !this._hexValuesSub.closed) {
            this._hexValuesSub.unsubscribe();
        }
        if (this._rgbValuesSub && !this._rgbValuesSub.closed) {
            this._rgbValuesSub.unsubscribe();
        }
    };
    MccColorPickerSelectorComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.render.listen(this._block.nativeElement, 'mousedown', function (e) {
            _this._isPressed = true;
            _this.changeColor(e);
        });
        this.render.listen(this._block.nativeElement, 'mouseup', function () { return (_this._isPressed = false); });
        this.render.listen(this._block.nativeElement, 'mouseout', function () { return (_this._isPressed = false); });
        this.render.listen(this._block.nativeElement, 'mousemove', function (e) { return _this.changeColor(e); });
        this._blockContext = this._bc.nativeElement.getContext('2d');
        this._blockContext.rect(0, 0, this._bc.nativeElement.width, this._bc.nativeElement.height);
        this.render.listen(this._strip.nativeElement, 'mousedown', function (e) {
            _this._isPressed = true;
            _this.changeBaseColor(e);
        });
        this.render.listen(this._strip.nativeElement, 'mouseup', function () { return (_this._isPressed = false); });
        this.render.listen(this._strip.nativeElement, 'mouseout', function () { return (_this._isPressed = false); });
        this.render.listen(this._strip.nativeElement, 'mousemove', function (e) { return _this.changeBaseColor(e); });
        this._stripContext = this._strip.nativeElement.getContext('2d');
        this._stripContext.rect(0, 0, this._strip.nativeElement.width, this._strip.nativeElement.height);
        var grd1 = this._stripContext.createLinearGradient(0, 0, 0, this._bc.nativeElement.height);
        grd1.addColorStop(0, 'rgba(255, 0, 0, 1)');
        grd1.addColorStop(0.17, 'rgba(255, 255, 0, 1)');
        grd1.addColorStop(0.34, 'rgba(0, 255, 0, 1)');
        grd1.addColorStop(0.51, 'rgba(0, 255, 255, 1)');
        grd1.addColorStop(0.68, 'rgba(0, 0, 255, 1)');
        grd1.addColorStop(0.85, 'rgba(255, 0, 255, 1)');
        grd1.addColorStop(1, 'rgba(255, 0, 0, 1)');
        this._stripContext.fillStyle = grd1;
        this._stripContext.fill();
        this._fillGradient();
    };
    MccColorPickerSelectorComponent.prototype._fillGradient = function () {
        this._blockContext.fillStyle = this._rgbaColor;
        this._blockContext.fillRect(0, 0, this._bc.nativeElement.width, this._bc.nativeElement.height);
        var grdWhite = this._stripContext.createLinearGradient(0, 0, this._bc.nativeElement.width, 0);
        grdWhite.addColorStop(0, 'rgba(255,255,255,1)');
        grdWhite.addColorStop(1, 'rgba(255,255,255,0)');
        this._blockContext.fillStyle = grdWhite;
        this._blockContext.fillRect(0, 0, this._bc.nativeElement.width, this._bc.nativeElement.height);
        var grdBlack = this._stripContext.createLinearGradient(0, 0, 0, this._bc.nativeElement.height);
        grdBlack.addColorStop(0, 'rgba(0,0,0,0)');
        grdBlack.addColorStop(1, 'rgba(0,0,0,1)');
        this._blockContext.fillStyle = grdBlack;
        this._blockContext.fillRect(0, 0, this._bc.nativeElement.width, this._bc.nativeElement.height);
    };
    MccColorPickerSelectorComponent.prototype._onChanges = function () {
        var _this = this;
        this._hexValuesSub = this.hexForm.get('hexCode').valueChanges.subscribe(function (value) {
            if (!_this._isPressed && isValidColor(value)) {
                _this._tmpSelectedColor.next(coerceHexaColor(value) || _this.emptyColor);
            }
        });
        this._rgbValuesSub = this.rgbForm.valueChanges.subscribe(function (controls) {
            var data = [];
            for (var key in controls) {
                if (!controls[key] || controls[key] > 255) {
                    data.push('');
                    continue;
                }
                data.push(controls[key]);
            }
            var hex = _this._getHex(data);
            if (hex !== _this._selectedColor && hex.length === 7) {
                _this._tmpSelectedColor.next(hex);
            }
        });
    };
    MccColorPickerSelectorComponent.prototype._getRGB = function (data) {
        if (data) {
            return [data[0], data[1], data[2]];
        }
        var hex = this._selectedColor.replace('#', '');
        var r = parseInt(hex.slice(0, 2), 16);
        var g = parseInt(hex.slice(2, 4), 16);
        var b = parseInt(hex.slice(4, 6), 16);
        return [r, g, b];
    };
    MccColorPickerSelectorComponent.prototype._getHex = function (data) {
        var hex = new Array(3);
        hex[0] = data[0].toString(16);
        hex[1] = data[1].toString(16);
        hex[2] = data[2].toString(16);
        hex.forEach(function (val, key) {
            if (val.length === 1) {
                hex[key] = '0' + hex[key];
            }
        });
        return coerceHexaColor("" + hex[0] + hex[1] + hex[2]) || this.emptyColor;
    };
    MccColorPickerSelectorComponent.prototype._updateRGBA = function (data) {
        if (!this._selectedColor && !data) {
            this._rgbaColor = 'rgba(255,0,0,1)';
        }
        var rgb = this._getRGB(data);
        this._rgbaColor = "rgba(" + rgb[0] + ", " + rgb[1] + ", " + rgb[2] + ", 1)";
    };
    MccColorPickerSelectorComponent.prototype._updateRGB = function (data) {
        if (!this.rgbForm) {
            return;
        }
        if (!data) {
            data = this._getRGB();
        }
        this.rgbForm.setValue({ R: data[0], G: data[1], B: data[2] });
    };
    MccColorPickerSelectorComponent.prototype.changeBaseColor = function (e) {
        if (this._isPressed) {
            this.render.setStyle(this._sc.nativeElement, 'background-position-y', e.offsetY + "px");
            var data = this._stripContext.getImageData(e.offsetX, e.offsetY, 1, 1).data;
            this._updateRGBA(data);
            this._fillGradient();
            this.updateValues(data);
        }
    };
    MccColorPickerSelectorComponent.prototype.changeColor = function (e) {
        if (this._isPressed) {
            this.render.setStyle(this._bp.nativeElement, 'top', e.offsetY - 5 + "px");
            this.render.setStyle(this._bp.nativeElement, 'left', e.offsetX - 5 + "px");
            var data = this._blockContext.getImageData(e.offsetX, e.offsetY, 1, 1).data;
            this.updateValues(data);
        }
    };
    MccColorPickerSelectorComponent.prototype.updateValues = function (data) {
        if (data) {
            this._updateRGB(data);
            this._tmpSelectedColor.next(this._getHex(data));
        }
    };
    return MccColorPickerSelectorComponent;
}());
MccColorPickerSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'mcc-color-picker-selector',
                template: "<div class=\"mcc-color-picker-selector\" [ngStyle]=\"{ 'height.px': selectorHeight }\">\n    <div #block class=\"mcc-picker-selector\"></div>\n    <canvas #blockCanvas [height]=\"selectorHeight\" width=\"230\" id=\"picker\"></canvas>\n    <div #blockPointer class=\"mcc-picker-position\" style=\"top: 0px;left: 220px;\"></div>\n    <div #stripContainer class=\"mcc-colors-position\" style=\"background-position-y: 0px;\">\n        <canvas #strip [height]=\"stripHeight\" width=\"20\" id=\"colors\"></canvas>\n    </div>\n</div>\n<div class=\"mcc-color-picker-selector-preview\" [style.background]=\"selectedColor\">\n    <ng-container *ngIf=\"!hideHexForms\">\n        <form [formGroup]=\"hexForm\">\n            <mat-form-field class=\"hex-input\" floatLabel=\"always\" [ngClass]=\"textClass\">\n                <input matInput placeholder=\"HEX\" maxlength=\"7\" formControlName=\"hexCode\" [value]=\"selectedColor\" />\n            </mat-form-field>\n        </form>\n        <form [formGroup]=\"rgbForm\">\n            <mat-form-field class=\"rgb-input\" floatLabel=\"always\" [ngClass]=\"textClass\">\n                <input matInput type=\"number\" placeholder=\"RGB\" maxlength=\"3\" formControlName=\"R\" />\n            </mat-form-field>\n            <mat-form-field class=\"rgb-input\" floatLabel=\"always\" [ngClass]=\"textClass\">\n                <input matInput type=\"number\" maxlength=\"3\" formControlName=\"G\" />\n            </mat-form-field>\n            <mat-form-field class=\"rgb-input\" floatLabel=\"always\" [ngClass]=\"textClass\">\n                <input matInput type=\"number\" maxlength=\"3\" formControlName=\"B\" />\n            </mat-form-field>\n        </form>\n    </ng-container>\n</div>",
                styles: ["canvas#colors{margin:5px}canvas:hover{cursor:crosshair}.mcc-picker-selector{position:absolute;width:230px;height:170px;top:0;left:0;z-index:10;cursor:crosshair}.mcc-picker-position{position:absolute;width:10px;height:10px;z-index:1;border:1px solid #ddd;border-radius:50%;background:rgba(0,0,0,.3)}.mcc-colors-position{position:absolute;width:30px;height:160px;top:0;right:0;z-index:1;background:url(data:image/gif;base64,R0lGODdhHgAIALMAAAAAADU1NTk5OUJCQkpKSlZWVltbW2pqaoCAgP///wAAAAAAAAAAAAAAAAAAAAAAACH5BAkAAAoALAAAAAAeAAgAAAQw0BhFq734yjJm/p8xFEVAeGCqGERACmahgkUrvPH81cFdnjoQy8VBBTOiguSokkQAADs=) no-repeat}.mcc-color-picker-selector{height:170px}/deep/ mat-form-field{font-family:'Open Sans';font-size:11px;font-weight:700}/deep/ mat-form-field.black{color:#100214}/deep/ mat-form-field.black label{color:#100214}/deep/ mat-form-field.black .mat-form-field-underline{background-color:#100214}/deep/ mat-form-field.white{color:#fff}/deep/ mat-form-field.white label{color:#fff}/deep/ mat-form-field.white .mat-form-field-underline{background-color:#fff}.mcc-color-picker-selector-preview{height:40px;padding:15px;border-bottom:1px solid #e1e1e1}.mcc-color-picker-selector-preview form{display:inline-block;position:relative}.mcc-color-picker-selector-preview .hex-input{width:75px;margin-right:20px}.mcc-color-picker-selector-preview .hex-input input{font-size:16px;font-weight:400}.mcc-color-picker-selector-preview .rgb-input{width:40px;margin-right:5px}.mcc-color-picker-selector-preview .rgb-input input{font-size:16px;font-weight:400}"],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
MccColorPickerSelectorComponent.ctorParameters = function () { return [
    { type: FormBuilder, },
    { type: Renderer2, },
    { type: undefined, decorators: [{ type: Inject, args: [EMPTY_COLOR,] },] },
]; };
MccColorPickerSelectorComponent.propDecorators = {
    "_block": [{ type: ViewChild, args: ['block',] },],
    "_bp": [{ type: ViewChild, args: ['blockPointer',] },],
    "blockCursor": [{ type: ViewChild, args: ['blockCanvas',] },],
    "_strip": [{ type: ViewChild, args: ['strip',] },],
    "stripCursor": [{ type: ViewChild, args: ['stripContainer',] },],
    "height": [{ type: Input, args: ['height',] },],
    "selectedColor": [{ type: Input },],
    "hideHexForms": [{ type: Input, args: ['hideHexForms',] },],
    "changeSelectedColor": [{ type: Output },],
};
var MccColorPickerOptionDirective = /** @class */ (function () {
    function MccColorPickerOptionDirective(elementRef, render, emptyColor) {
        this.elementRef = elementRef;
        this.render = render;
        this.emptyColor = emptyColor;
        this._color = emptyColor;
    }
    Object.defineProperty(MccColorPickerOptionDirective.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    MccColorPickerOptionDirective.prototype.ngAfterViewInit = function () {
        if (this.color) {
            var color = void 0;
            if (typeof this.color === 'string') {
                color = this.color;
            }
            else {
                color = this.color.value;
                this.render.setAttribute(this.elementRef.nativeElement, 'aria-label', this.color.text);
            }
            if (isValidColor(color)) {
                this.render.setStyle(this.elementRef.nativeElement, 'background', coerceHexaColor(color) || this.emptyColor);
            }
        }
    };
    return MccColorPickerOptionDirective;
}());
MccColorPickerOptionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mccColorPickerOption], [mcc-color-picker-option]',
                exportAs: 'mccColorPickerOption',
            },] },
];
MccColorPickerOptionDirective.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: undefined, decorators: [{ type: Inject, args: [EMPTY_COLOR,] },] },
]; };
MccColorPickerOptionDirective.propDecorators = {
    "color": [{ type: Input, args: ['mccColorPickerOption',] },],
};
var MccColorPickerOriginDirective = /** @class */ (function () {
    function MccColorPickerOriginDirective(elementRef, renderer, emptyColor) {
        var _this = this;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.emptyColor = emptyColor;
        this.change = new BehaviorSubject('');
        renderer.listen(elementRef.nativeElement, 'keyup', function (event) {
            var value = event.currentTarget['value'];
            if (event.isTrusted && isValidColor(value)) {
                _this.writeValueFromKeyup(coerceHexaColor(value) || _this.emptyColor);
            }
        });
    }
    MccColorPickerOriginDirective.prototype.writeValue = function (color) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'value', color);
        this.change.next(color);
        if (this.propagateChanges) {
            this.propagateChanges(color);
        }
    };
    MccColorPickerOriginDirective.prototype.writeValueFromColorPicker = function (color) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'value', color);
        this.propagateChanges(color);
    };
    MccColorPickerOriginDirective.prototype.writeValueFromKeyup = function (color) {
        this.change.next(color);
        this.propagateChanges(color);
    };
    MccColorPickerOriginDirective.prototype.registerOnChange = function (fn) {
        this.propagateChanges = fn;
    };
    MccColorPickerOriginDirective.prototype.registerOnTouched = function (fn) { };
    MccColorPickerOriginDirective.prototype.setDisabledState = function (isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    };
    return MccColorPickerOriginDirective;
}());
MccColorPickerOriginDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mcc-color-picker-origin], [mccColorPickerOrigin]',
                exportAs: 'mccColorPickerOrigin',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(function () { return MccColorPickerOriginDirective; }),
                        multi: true,
                    },
                ],
            },] },
];
MccColorPickerOriginDirective.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: undefined, decorators: [{ type: Inject, args: [EMPTY_COLOR,] },] },
]; };
MccColorPickerOriginDirective.propDecorators = {
    "change": [{ type: Output },],
};
var MccConnectedColorPickerDirective = /** @class */ (function () {
    function MccConnectedColorPickerDirective(colorPicker, changeDetectorRef, emptyColor) {
        this.colorPicker = colorPicker;
        this.changeDetectorRef = changeDetectorRef;
        this.emptyColor = emptyColor;
    }
    MccConnectedColorPickerDirective.prototype.ngAfterViewInit = function () {
        if (!this._colorPickerSub) {
            this._attachColorPicker();
        }
    };
    MccConnectedColorPickerDirective.prototype.ngOnDestroy = function () {
        if (this._colorPickerSub && !this._colorPickerSub.closed) {
            this._colorPickerSub.unsubscribe();
        }
        if (this._originSub && !this._originSub.closed) {
            this._originSub.unsubscribe();
        }
    };
    MccConnectedColorPickerDirective.prototype._attachColorPicker = function () {
        var _this = this;
        this._originSub = this.origin.change.subscribe(function (value) {
            if (isValidColor(value) ||
                (value === _this.emptyColor && _this.colorPicker.selectedColor !== _this.emptyColor)) {
                _this.colorPicker.updateTmpSelectedColor(value);
            }
            _this.colorPicker.selectedColor = value;
            _this.changeDetectorRef.detectChanges();
        });
        this._colorPickerSub = this.colorPicker.change.subscribe(function (value) { return _this.origin.writeValueFromColorPicker(value); });
    };
    return MccConnectedColorPickerDirective;
}());
MccConnectedColorPickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mcc-connected-color-picker], [mccConnectedColorPicker]',
                exportAs: 'mccConnectedColorPicker',
            },] },
];
MccConnectedColorPickerDirective.ctorParameters = function () { return [
    { type: MccColorPickerComponent, },
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Inject, args: [EMPTY_COLOR,] },] },
]; };
MccConnectedColorPickerDirective.propDecorators = {
    "origin": [{ type: Input, args: ['mccConnectedColorPickerOrigin',] },],
};
var MccColorPickerModule = /** @class */ (function () {
    function MccColorPickerModule() {
    }
    MccColorPickerModule.forRoot = function (config) {
        return {
            ngModule: MccColorPickerModule,
            providers: [{ provide: EMPTY_COLOR, useValue: config.empty_color }],
        };
    };
    return MccColorPickerModule;
}());
MccColorPickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    PortalModule,
                    OverlayModule,
                    ReactiveFormsModule,
                    MatButtonModule,
                    MatFormFieldModule,
                    MatInputModule,
                ],
                declarations: [
                    MccColorPickerComponent,
                    MccConnectedColorPickerDirective,
                    MccColorPickerSelectorComponent,
                    MccColorPickerOriginDirective,
                    MccColorPickerOptionDirective,
                    MccColorPickerCollectionComponent,
                ],
                exports: [
                    MccColorPickerComponent,
                    MccConnectedColorPickerDirective,
                    MccColorPickerOriginDirective,
                    MccColorPickerCollectionComponent,
                ],
                providers: [MccColorPickerService, { provide: EMPTY_COLOR, useValue: 'none' }],
            },] },
];
MccColorPickerModule.ctorParameters = function () { return []; };
var HOURS = ['12', '11', '1', '10', '2', '9', '3', '8', '4', '7', '5', '6'];
var MINUTES = [
    '00',
    '55',
    '05',
    '50',
    '10',
    '45',
    '15',
    '40',
    '20',
    '35',
    '25',
    '30',
];
var MccTimerPickerComponent = /** @class */ (function () {
    function MccTimerPickerComponent() {
        this._clock = new BehaviorSubject(HOURS);
        this._focus = 'hour';
        this._hour = '12';
        this._minute = '00';
        this._period = 'am';
        this._hideButtons = false;
        this.format = '12';
        this.btnCancel = 'Cancel';
        this.btnConfirm = 'Ok';
        this.selected = new EventEmitter();
        this.connected = false;
    }
    Object.defineProperty(MccTimerPickerComponent.prototype, "clock$", {
        get: function () {
            return this._clock.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccTimerPickerComponent.prototype, "focus", {
        get: function () {
            return this._focus;
        },
        set: function (value) {
            if (value !== this._focus) {
                this._focus = value;
                this._clock.next(this._focus === 'hour' ? HOURS : MINUTES);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccTimerPickerComponent.prototype, "isOpen", {
        get: function () {
            return this._isOpen;
        },
        set: function (value) {
            this._isOpen = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccTimerPickerComponent.prototype, "hour", {
        get: function () {
            return this._hour;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccTimerPickerComponent.prototype, "minute", {
        get: function () {
            return this._minute;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccTimerPickerComponent.prototype, "period", {
        get: function () {
            return this._period;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccTimerPickerComponent.prototype, "hideButtons", {
        get: function () {
            return this._hideButtons;
        },
        set: function (value) {
            this._hideButtons = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    MccTimerPickerComponent.prototype.getSelectedClass = function () {
        var _this = this;
        var name = 'selected-index-';
        if (this.focus === 'hour') {
            name += HOURS.findIndex(function (h) { return h === _this.hour; });
        }
        else {
            name += MINUTES.findIndex(function (m) { return m === _this.minute; });
        }
        return name;
    };
    MccTimerPickerComponent.prototype.select = function (value) {
        if (this.focus === 'hour') {
            this._hour = (value);
            this.focus = 'min';
        }
        else {
            this._minute = (value);
        }
        if (this._hideButtons) {
            this.confirmSelectedTime();
        }
    };
    MccTimerPickerComponent.prototype.changePeriod = function (period) {
        this._period = period;
        if (this._hideButtons) {
            this.confirmSelectedTime();
        }
    };
    MccTimerPickerComponent.prototype.backdropClick = function () {
        this.confirmSelectedTime();
        this._isOpen = false;
    };
    MccTimerPickerComponent.prototype.cancelSelection = function () {
        this._hour = this._selectedHour;
        this._minute = this._selectedMinute;
        this._period = this._selectedPeriod;
        this._isOpen = false;
    };
    MccTimerPickerComponent.prototype.confirmSelectedTime = function () {
        this._selectedHour = this.hour;
        this._selectedMinute = this.minute;
        this._selectedPeriod = this.period;
        var formated;
        if (this.format === '12') {
            formated = this.hour + ":" + this.minute + " " + this.period;
        }
        else {
            var hour = this.hour;
            if (this.period === 'pm') {
                hour = "" + (parseInt(hour) + 12);
            }
            formated = hour + ":" + this.minute;
        }
        this.selected.emit(formated);
        if (!this._hideButtons) {
            this._isOpen = false;
        }
    };
    return MccTimerPickerComponent;
}());
MccTimerPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'mcc-timer-picker',
                template: "<!-- show component inside overlay -->\n<ng-container *ngIf=\"connected\">\n  <ng-template cdkConnectedOverlay cdkConnectedOverlayHasBackdrop cdkConnectedOverlayBackdropClass=\"mcc-timer-picker-backdrop\" [cdkConnectedOverlayOrigin]=\"trigger\"\n    [cdkConnectedOverlayOpen]=\"isOpen\" (backdropClick)=\"backdropClick()\">\n    <ng-template [cdkPortalOutlet]=\"panelComponent\"></ng-template>\n  </ng-template>\n</ng-container>\n<ng-template *ngIf=\"!connected\" [cdkPortalOutlet]=\"panelComponent\"></ng-template>\n<ng-template cdkPortal #panelComponent=\"cdkPortal\">\n  <div class=\"mcc-timer-picker-overlay mat-elevation-z6\" role=\"dialog\" aria-label=\"Timer picker\">\n    <div class=\"mcc-timer-picker-header mat-primary\">\n      <button mat-icon-button class=\"mcc-timer-picker-hours\" [ngClass]=\"{ 'mcc-active': focus === 'hour' }\" (click)=\"focus = 'hour'\">\n        {{ hour }}\n      </button>\n      <span class=\"mcc-timer-picker-separator\"></span>\n      <button mat-icon-button class=\"mcc-timer-picker-minutes\" [ngClass]=\"{ 'mcc-active': focus === 'min' }\" (click)=\"focus = 'min'\">\n        {{ minute }}\n      </button>\n      <div class=\"mcc-timer-picker-am-pm\">\n        <button mat-icon-button [ngClass]=\"{ 'mcc-active': period === 'am' }\" (click)=\"changePeriod('am')\">\n          AM\n        </button>\n        <button mat-icon-button [ngClass]=\"{ 'mcc-active': period === 'pm' }\" (click)=\"changePeriod('pm')\">\n          PM\n        </button>\n      </div>\n    </div>\n    <div class=\"mcc-timer-picker-content\">\n      <div class=\"mcc-timer-picker-clock\">\n        <div class=\"mcc-timer-picker-dot\"></div>\n        <div class=\"mcc-timer-picker-line\" [ngClass]=\"getSelectedClass()\"></div>\n        <ng-container *ngFor=\"let option of clock$ | async;let i = index;\">\n          <button mat-icon-button class=\"mcc-timer-picker-option\" [ngClass]=\"{ 'mcc-timer-picker-option-selected': focus === 'hour' && hour == option || focus === 'min' && minute === option }\"\n            [id]=\"'option-'+i\" (click)=\"select(option)\">\n            {{ option }}\n          </button>\n        </ng-container>\n      </div>\n    </div>\n    <div *ngIf=\"!hideButtons\" class=\"mcc-timer-picker-actions\" dir=\"rtl\">\n      <button mat-button role=\"button\" aria-label=\"Confirm\" (click)=\"confirmSelectedTime()\">\n        {{ btnConfirm }}\n      </button>\n      <button mat-button role=\"button\" aria-label=\"Cancel\" (click)=\"cancelSelection()\">\n        {{ btnCancel }}\n      </button>\n    </div>\n  </div>\n</ng-template>",
                styles: ["@import url(https://fonts.googleapis.com/css?family=Roboto);.mcc-timer-picker-overlay{width:325px;height:480px}.mcc-timer-picker-header{display:-webkit-box;display:-ms-flexbox;display:flex;width:215px;height:65px;padding:15px 0 15px 110px;background:#00796b}.mcc-timer-picker-hours,.mcc-timer-picker-minutes{width:63px;height:63px;font-family:Roboto,sans-serif;font-size:50px;font-weight:400;color:rgba(255,255,255,.3)}.mcc-timer-picker-hours.mcc-standalone,.mcc-timer-picker-minutes.mcc-standalone{text-align:right}.mcc-timer-picker-hours.mcc-active,.mcc-timer-picker-minutes.mcc-active{color:#fff}.mcc-timer-picker-separator{font-family:Roboto,sans-serif;font-size:43px;font-weight:400;color:rgba(255,255,255,.3);margin:5px 5px 0 0}.mcc-timer-picker-separator::after{content:':'}.mcc-timer-picker-am-pm{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin:10px}.mcc-timer-picker-am-pm button{width:25px;height:25px;line-height:25px;font-family:Roboto,sans-serif;font-size:12px;font-weight:400;color:rgba(255,255,255,.3)}.mcc-timer-picker-am-pm button.mcc-active{color:#fff}.mcc-timer-picker-content{width:inherit;height:310px;padding:15px 0;background-color:#fff}.mcc-timer-picker-clock{position:relative;width:300px;height:300px;margin:0 auto;background-color:#eee;border-radius:50%;text-align:center}.mcc-timer-picker-clock .mcc-timer-picker-dot{position:absolute;width:6px;height:6px;border-radius:50%;background-color:#00796b;top:147px;left:147px}.mcc-timer-picker-clock .mcc-timer-picker-line{position:absolute;width:115px;height:2px;background-color:#00796b}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-0{top:92px;left:92px;-webkit-transform:rotateZ(90deg);transform:rotateZ(90deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-1{top:101px;left:58px;-webkit-transform:rotateZ(414deg);transform:rotateZ(414deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-2{top:100px;left:128px;-webkit-transform:rotateZ(126deg);transform:rotateZ(126deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-3{top:123px;left:39px;-webkit-transform:rotateZ(386deg);transform:rotateZ(386deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-4{top:124px;left:142px;-webkit-transform:rotateZ(153deg);transform:rotateZ(153deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-5{top:149px;left:34px;-webkit-transform:rotateZ(360deg);transform:rotateZ(360deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-6{top:149px;left:147px;-webkit-transform:rotateZ(180deg);transform:rotateZ(180deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-7{top:177px;left:42px;-webkit-transform:rotateZ(331deg);transform:rotateZ(331deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-8{top:178px;left:142px;-webkit-transform:rotateZ(210deg);transform:rotateZ(210deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-9{top:196px;left:58px;-webkit-transform:rotateZ(306deg);transform:rotateZ(306deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-10{top:195px;left:128px;-webkit-transform:rotateZ(233deg);transform:rotateZ(233deg)}.mcc-timer-picker-clock .mcc-timer-picker-line.selected-index-11{top:208px;left:92px;-webkit-transform:rotateZ(270deg);transform:rotateZ(270deg)}.mcc-timer-picker-clock .mcc-timer-picker-option{position:absolute}.mcc-timer-picker-clock .mcc-timer-picker-option.mcc-timer-picker-option-selected{color:#fff;background-color:#00796b}.mcc-timer-picker-clock .mcc-timer-picker-option#option-0{top:0;left:130px}.mcc-timer-picker-clock .mcc-timer-picker-option#option-1{top:25px;left:55px}.mcc-timer-picker-clock .mcc-timer-picker-option#option-2{top:25px;right:55px}.mcc-timer-picker-clock .mcc-timer-picker-option#option-3{top:70px;left:15px}.mcc-timer-picker-clock .mcc-timer-picker-option#option-4{top:70px;right:15px}.mcc-timer-picker-clock .mcc-timer-picker-option#option-5{top:130px;left:0}.mcc-timer-picker-clock .mcc-timer-picker-option#option-6{top:130px;right:0}.mcc-timer-picker-clock .mcc-timer-picker-option#option-7{bottom:65px;left:15px}.mcc-timer-picker-clock .mcc-timer-picker-option#option-8{bottom:65px;right:15px}.mcc-timer-picker-clock .mcc-timer-picker-option#option-9{bottom:25px;left:55px}.mcc-timer-picker-clock .mcc-timer-picker-option#option-10{bottom:25px;right:55px}.mcc-timer-picker-clock .mcc-timer-picker-option#option-11{bottom:0;left:130px}.mcc-timer-picker-actions{display:-webkit-box;display:-ms-flexbox;display:flex;padding:4px;background-color:#fff}.mcc-timer-picker-actions button{color:#100214;text-transform:uppercase;font-family:Roboto,sans-serif;font-size:14px;font-weight:400}"],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
MccTimerPickerComponent.ctorParameters = function () { return []; };
MccTimerPickerComponent.propDecorators = {
    "hideButtons": [{ type: Input },],
    "format": [{ type: Input, args: ['mccTimerPickerFormat',] },],
    "btnCancel": [{ type: Input },],
    "btnConfirm": [{ type: Input },],
    "selected": [{ type: Output },],
};
var MccTimerPickerOriginDirective = /** @class */ (function () {
    function MccTimerPickerOriginDirective(elementRef, renderer) {
        var _this = this;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.change = new BehaviorSubject('');
        this.hasFocus = new BehaviorSubject(false);
        renderer.listen(elementRef.nativeElement, 'focus', function () { return _this.hasFocus.next(true); });
    }
    MccTimerPickerOriginDirective.prototype.writeValue = function (time) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'value', time);
        this.change.next(time);
        if (this.propagateChanges) {
            this.propagateChanges(time);
        }
    };
    MccTimerPickerOriginDirective.prototype.writeValueFromTimerPicker = function (time) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'value', time);
        this.propagateChanges(time);
    };
    MccTimerPickerOriginDirective.prototype.writeValueFromKeyup = function (time) {
        this.change.next(time);
        this.propagateChanges(time);
    };
    MccTimerPickerOriginDirective.prototype.registerOnChange = function (fn) {
        this.propagateChanges = fn;
    };
    MccTimerPickerOriginDirective.prototype.registerOnTouched = function (fn) { };
    MccTimerPickerOriginDirective.prototype.setDisabledState = function (isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    };
    return MccTimerPickerOriginDirective;
}());
MccTimerPickerOriginDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mccTimerPickerOrigin], [mcc-timer-picker-origin]',
                exportAs: 'mccTimerPickerOrigin',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(function () { return MccTimerPickerOriginDirective; }),
                        multi: true,
                    },
                ],
            },] },
];
MccTimerPickerOriginDirective.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: Renderer2, },
]; };
MccTimerPickerOriginDirective.propDecorators = {
    "change": [{ type: Output },],
    "hasFocus": [{ type: Output },],
};
var MccConnectedTimerPickerDirective = /** @class */ (function () {
    function MccConnectedTimerPickerDirective(timerPicker, changeDetectorRef) {
        this.timerPicker = timerPicker;
        this.changeDetectorRef = changeDetectorRef;
        this.timerPicker.connected = true;
    }
    MccConnectedTimerPickerDirective.prototype.ngAfterViewInit = function () {
        if (!this._timerPickerSub) {
            this.timerPicker.trigger = this.origin;
            this._attachTimerPicker();
        }
    };
    MccConnectedTimerPickerDirective.prototype.ngOnDestroy = function () {
        if (this._originFocus && !this._originFocus.closed) {
            this._originFocus.unsubscribe();
        }
        if (this._timerPickerSub && !this._timerPickerSub.closed) {
            this._timerPickerSub.unsubscribe();
        }
    };
    MccConnectedTimerPickerDirective.prototype._attachTimerPicker = function () {
        var _this = this;
        this._originFocus = this.origin.hasFocus.subscribe(function (focused) {
            _this.timerPicker.focus = 'hour';
            _this.timerPicker.isOpen = focused;
            _this.changeDetectorRef.detectChanges();
        });
        this._timerPickerSub = this.timerPicker.selected.subscribe(function (value) { return _this.origin.writeValueFromTimerPicker(value); });
    };
    return MccConnectedTimerPickerDirective;
}());
MccConnectedTimerPickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mccConnectedTimerPicker], [mcc-connected-timer-picker]',
                exportAs: 'mccConnectedTimerPicker',
            },] },
];
MccConnectedTimerPickerDirective.ctorParameters = function () { return [
    { type: MccTimerPickerComponent, },
    { type: ChangeDetectorRef, },
]; };
MccConnectedTimerPickerDirective.propDecorators = {
    "origin": [{ type: Input, args: ['mccConnectedTimerPickerOrigin',] },],
};
var MccTimerPickerModule = /** @class */ (function () {
    function MccTimerPickerModule() {
    }
    return MccTimerPickerModule;
}());
MccTimerPickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, PortalModule, OverlayModule, MatButtonModule],
                declarations: [
                    MccTimerPickerComponent,
                    MccTimerPickerOriginDirective,
                    MccConnectedTimerPickerDirective,
                ],
                exports: [
                    MccTimerPickerComponent,
                    MccTimerPickerOriginDirective,
                    MccConnectedTimerPickerDirective,
                ],
            },] },
];
MccTimerPickerModule.ctorParameters = function () { return []; };
var SCROLLSPY_ANIMATION_SMOOTH = 'smooth';
var MccScrollspyService = /** @class */ (function () {
    function MccScrollspyService(window) {
        var _this = this;
        this.window = window;
        this._fromClick = false;
        this.data = [];
        this._scrollSub = fromEvent(window, 'scroll')
            .pipe(debounceTime(50), withLatestFrom(function () { return window.scrollY; }))
            .subscribe(function (position) {
            if (!_this._fromClick) {
                _this._updateFocused(position);
            }
            _this._fromClick = false;
        });
    }
    MccScrollspyService.prototype.ngOnDestroy = function () {
        if (this._scrollSub && !this._scrollSub.closed) {
            this._scrollSub.unsubscribe();
        }
    };
    MccScrollspyService.prototype._updateFocused = function (position) {
        this.data.forEach(function (group) {
            var items = [];
            group.items.getValue().forEach(function (item, index) {
                item.focus = false;
                if (item.top <= position) {
                    if (items[index - 1]) {
                        items[index - 1].focus = false;
                    }
                    item.focus = true;
                }
                items.push(item);
            });
            group.items.next(items);
        });
    };
    MccScrollspyService.prototype.create = function (name, items, animation) {
        var group = this.data.find(function (group) { return group.name === name; });
        if (!group) {
            group = {
                name: name,
                animation: animation || SCROLLSPY_ANIMATION_SMOOTH,
                items: new BehaviorSubject(items || []),
            };
            this.data.push(group);
        }
        else {
            group.items.next(items || []);
        }
        return group;
    };
    MccScrollspyService.prototype.group = function (name) {
        var group = this.data.find(function (g) { return g.name === name; });
        if (!group) {
            group = this.create(name);
        }
        return group.items.asObservable();
    };
    MccScrollspyService.prototype.scrollTo = function (name, id) {
        var _this = this;
        var group = this.data.find(function (group) { return group.name === name; });
        group.items.getValue().forEach(function (item) {
            item.focus = false;
            if (item.id === id) {
                _this._fromClick = true;
                _this._updateFocused(item.top);
                window.scrollTo({ top: item.top, behavior: group.animation });
            }
        });
    };
    return MccScrollspyService;
}());
MccScrollspyService.decorators = [
    { type: Injectable },
];
MccScrollspyService.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] },] },
]; };
var MccScrollspyItemDirective = /** @class */ (function () {
    function MccScrollspyItemDirective(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
    }
    Object.defineProperty(MccScrollspyItemDirective.prototype, "id", {
        get: function () {
            return this._id;
        },
        set: function (id) {
            if (!id) {
                id = this._createId();
                this.renderer.setProperty(this.elementRef.nativeElement, 'id', id);
            }
            this._id = id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccScrollspyItemDirective.prototype, "top", {
        get: function () {
            return this.elementRef.nativeElement.offsetTop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccScrollspyItemDirective.prototype, "focus", {
        get: function () {
            return this._focused;
        },
        set: function (focused) {
            this._focused = coerceBooleanProperty(focused);
        },
        enumerable: true,
        configurable: true
    });
    MccScrollspyItemDirective.prototype.ngAfterContentInit = function () {
        if (!this.label) {
            this.label = this.elementRef.nativeElement.textContent;
        }
        this.id = this.elementRef.nativeElement.id;
    };
    MccScrollspyItemDirective.prototype._createId = function () {
        var tmpID = this.label.toLowerCase().replace(/[ ]+/gi, '_');
        return "mcc_scrollspy_" + tmpID;
    };
    return MccScrollspyItemDirective;
}());
MccScrollspyItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mccScrollspyItem], [mcc-scrollspy-item]',
                exportAs: 'mccScrollspyItem',
            },] },
];
MccScrollspyItemDirective.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: Renderer2, },
]; };
MccScrollspyItemDirective.propDecorators = {
    "focus": [{ type: Input, args: ['focus',] },],
    "label": [{ type: Input },],
};
var MccScrollspyGroupDirective = /** @class */ (function () {
    function MccScrollspyGroupDirective(mccScrollspyService) {
        this.mccScrollspyService = mccScrollspyService;
    }
    Object.defineProperty(MccScrollspyGroupDirective.prototype, "name", {
        set: function (name) {
            this._name = name;
        },
        enumerable: true,
        configurable: true
    });
    MccScrollspyGroupDirective.prototype.ngAfterContentInit = function () {
        var items = this.items.map(function (item) { return item; });
        this.mccScrollspyService.create(this._name, items);
    };
    return MccScrollspyGroupDirective;
}());
MccScrollspyGroupDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mccScrollspyGroup], [mcc-scrollspy-group]',
                exportAs: 'mccScrollspyGroup',
            },] },
];
MccScrollspyGroupDirective.ctorParameters = function () { return [
    { type: MccScrollspyService, },
]; };
MccScrollspyGroupDirective.propDecorators = {
    "items": [{ type: ContentChildren, args: [MccScrollspyItemDirective,] },],
    "name": [{ type: Input, args: ['mccScrollspyGroup',] },],
};
var ɵ0 = window;
var MccScrollspyModule = /** @class */ (function () {
    function MccScrollspyModule() {
    }
    return MccScrollspyModule;
}());
MccScrollspyModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ScrollDispatchModule],
                providers: [MccScrollspyService, { provide: 'Window', useValue: ɵ0 }],
                declarations: [MccScrollspyGroupDirective, MccScrollspyItemDirective],
                exports: [MccScrollspyGroupDirective, MccScrollspyItemDirective],
            },] },
];
MccScrollspyModule.ctorParameters = function () { return []; };

export { MccColorPickerModule, MccColorPickerService, EMPTY_COLOR, MccTimerPickerModule, MccScrollspyModule, MccScrollspyService, MccScrollspyItemDirective, MccColorPickerCollectionComponent as ɵc, MccColorPickerSelectorComponent as ɵg, MccColorPickerComponent as ɵb, MccColorPickerOptionDirective as ɵd, MccColorPickerOriginDirective as ɵe, MccConnectedColorPickerDirective as ɵf, MccScrollspyGroupDirective as ɵa, MccTimerPickerComponent as ɵh, MccConnectedTimerPickerDirective as ɵj, MccTimerPickerOriginDirective as ɵi };
//# sourceMappingURL=material-community-components.js.map
